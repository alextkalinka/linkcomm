%\VignetteIndexEntry{A step-by-step guide to using linkcomm}
%\VignetteDepends{grid, igraph, RColorBrewer}
%\VignetteKeyword{linkcomm}
%\VignettePackage{linkcomm}

\documentclass[a4paper, oneside, 10pt]{article}

\usepackage[pdftex]{graphicx}
\usepackage{calc}
\usepackage{sectsty}
\usepackage{caption}
\usepackage{natbib}
\renewcommand{\captionfont}{\it\sffamily}
\renewcommand{\captionlabelfont}{\bf\sffamily}
\allsectionsfont{\sffamily}

\usepackage[a4paper, left=25mm, right=20mm, top=20mm, bottom=25mm, nohead]{geometry}
\setlength{\parskip}{1.5ex}
\setlength{\parindent}{0cm}
\pagestyle{plain}

\usepackage{Sweave}


\title{The generation, visualization, and analysis of link communities in arbitrary networks with the R package \textbf{linkcomm}}
\author{Alex T. Kalinka}
\date{\today \\
	alex.t.kalinka@gmail.com \\
	\small{Institute for Population Genetics, Vetmeduni Vienna, Veterin{\"a}rplatz 1, 1210 Vienna, Austria.}}

\begin{document}
\maketitle


\begin{abstract}

\noindent Identifying communities of related nodes in networks is an essential tool enabling researchers to make sense of complex data sets. The {\tt linkcomm} package greatly facilitates this process by extracting communities of links from networks of arbitrary size and type. By clustering links, as opposed to nodes, it is possible for nodes to belong to multiple communities thereby revealing the overlapping and nested structure of the network and uncovering the key nodes that form connections across several communities. In addition to this, {\tt linkcomm} provides extensive functionality for visualizing and analysing the resulting link communities. {\tt linkcomm} also provides tools for generating, visualizing, and analysing clusters generated by the Overlapping Cluster Generator (OCG) algorithm.


\end{abstract}



\tableofcontents

\clearpage

\section{Introduction}

The representation of systems of interacting elements as networks has brought fresh perspectives and insights to the analysis of complex phenomena from the biological to the social sciences. When analysing the structure, function, and dynamics of these networks it is extremely useful to identify sets of related nodes, known as communities \citep{radicchietal2004}.

This approach is greatly enhanced by clustering the links between nodes, rather than the nodes themselves \citep{evans&lambiotte2009, ahnetal2010}. With this method it is possible for nodes to belong to multiple communities, and this in turn reveals the overlapping and nested structure of the network while simultaneously identifying key nodes with membership across several communities.

The R package {\tt linkcomm} \citep{kalinka&tomancak2011} implements the algorithm proposed by \cite{ahnetal2010}. Similarities between links that share a node are assigned using the Jaccard coefficient and these similarities are then used to hierarchically cluster the links. The resulting dendrogram is cut at a point that maximises the density of links within the clusters after normalizing against the maximum and minimum numbers of links possible in each cluster.

<<echo = FALSE, eval = FALSE>>=
source("load_linkcomm.R")
source("load_OCG.R")
@

\section{Quick start}

To install {\tt linkcomm} run the following command within R:

<<eval = FALSE>>=
install.packages("linkcomm")
@

To load {\tt linkcomm} into your current R session:

<<eval = TRUE>>=
library(linkcomm)
@

\noindent To run an interactive demonstration of {\tt linkcomm} within R:

<<eval = FALSE>>=
demo(topic = "linkcomm", package = "linkcomm")
@

\noindent Four networks are provided as part of the package so that users can see how the functions work before using their own data:

\begin{enumerate}
\item A co-appearance network for the stage musical of \emph{Les Mis\'{e}rables} ({\tt lesmiserables}).
\item A social network of friendships between the members of a karate club ({\tt karate}).
\item A sub-network of protein interactions from the yeast interactome ({\tt pp\_rnapol}).
\item A sub-network of protein interactions from the human interactome ({\tt human\_pp}).
\end{enumerate}

\noindent Each network is arranged as an edge list and stored as a data frame. Other acceptable formats for input networks are character or integer matrices.

<<>>=
head(lesmiserables)
@


\clearpage


\section{Example session}

To illustrate the package we will extract communities from a densely-connected sub-network from the yeast protein interactome \citep{yuetal2008}. This sub-network includes 56 proteins and 449 interactions involved in transcription (see \cite{ahnetal2010}, SI, p. 16). The network is undirected and unweighted (see section \ref{sec:dirweight} for dealing with directed and weighted networks).

\subsection{Extracting link communities}

When extracting communities from a network, the input data must be arranged as a simple edge list.


<<eval = FALSE>>=
yeast_pp <- read.table("pp_rnapol.txt", header = FALSE)
head(yeast_pp)
@

<<echo = FALSE>>=
load(file = "networks.rda")
zz<-data.frame(V1=pp_rnapol[,1],V2=pp_rnapol[,2])
head(zz)
@

\noindent In the above edge list, each row corresponds to an interaction between the elements in each of the columns. The interacting elements can be character names, as above, or integer numbers. We will extract link communities from this network using the ``single'' hierarchical clustering method, specified using the {\tt hcmethod} argument (several clustering methods are available for networks that can be handled in the memory, see {\tt ?getLinkCommunities} - the default is {\tt average}).

<<eval = FALSE>>=
lc <- getLinkCommunities(yeast_pp, hcmethod = "single")
@

<<echo = FALSE>>=
cat("   Removing loops...\n   Removing edge duplicates...\n   Calculating edge similarities for 449 edges... 100.00%\n   Hierarchical clustering of edges...\n   Calculating link densities... 100.00%\n   Partition density maximum height =  0.33333\n   Finishing up...4/4... 100%\n   Plotting...\n   Colouring dendrogram... 100%\n")
@


\begin{figure}[!ht]%figure1
\centerline{\includegraphics[width=5in]{fig1_vignette.pdf}}
\caption{Example output from extracting link communities from a yeast protein interaction network involved in transcription.}\label{exampleoutput}
\end{figure}


\noindent The algorithm returns an object of class {\tt linkcomm} and plots a summary of the results (Fig. \ref{exampleoutput}). Included in this object are the communities that were extracted together with additional data required for plotting and further analysing the communities (see {\tt ?getLinkCommunities} for the elements of the {\tt linkcomm} object). \\ 

\noindent To view a summary of this object:

<<results = hide, echo = FALSE>>=
lc <- getLinkCommunities(pp_rnapol, hcmethod = "single")
@

<<>>=
print(lc)
@ 



%\setkeys{Gin}{width=2\linewidth}
\begin{figure}[!ht]
\advance\leftskip -3cm
\centerline{\includegraphics[width=6.5in]{graph_layout_examples.pdf}}
%<<fig = TRUE, echo = FALSE>>=
%par(mfcol=c(2,1),mar=rep(0,4),pty="m",mgp=rep(0,3),xpd=NA)
%plot(lc, type = "graph", layout = "spencer.circle", verbose = FALSE, shownodesin = 3, jitter = 0.5, margin = -0.1)
%plot(lc, type = "graph", layout = layout.fruchterman.reingold, shownodesin = 3, margin = -0.2)
%@
\caption{Visualization of link communities using graphs. The panel on the left shows a Spencer circle layout \citep{spencer2010}, while the panel on the right shows a Fruchterman-Reingold layout. In both graphs, we show only the nodes that belong to 3 or more communities. Numbers around the circumference of the circle refer to community IDs.}\label{graphs}
\end{figure}

\begin{figure}[!ht]
\advance\leftskip -3cm
\centerline{\includegraphics[width=4.5in]{nodepie_linkcomm.pdf}}

\caption{Visualization of link communities using node pies. The fraction of the total number of edges that a node has in each community is depicted using a pie chart.}\label{nodepies}
\end{figure}


\subsection{Visualizing link communities}

We can visualize link communities using coloured edges in a graph layout. 

<<eval = FALSE>>=
plot(lc, type = "graph", layout = layout.fruchterman.reingold)
plot(lc, type = "graph", layout = "spencer.circle")
@

\noindent To aid the visualization of key nodes we can limit the display of nodes using the {\tt shownodesin} parameter. The following displays only the nodes that belong to 3 or more communities (Fig. \ref{graphs}):

<<eval = FALSE>>=
plot(lc, type = "graph", layout = "spencer.circle", shownodesin = 3)
@

\noindent It's also possible to visualize node membership to different communities using node pies, in which the relative fraction of edges a node has in each community is depicted using a pie chart (Fig. \ref{nodepies}): 

<<eval = FALSE>>=
plot(lc, type = "graph", shownodesin = 2, node.pies = TRUE)
@


\noindent We can also visualize node community membership for the top-connected nodes using a community membership matrix (Fig. \ref{members}):

<<eval = FALSE>>=
plot(lc, type = "members")
@

\noindent We can also display a summary of the results of the link communities algorithm (Fig. \ref{exampleoutput}):

<<eval = FALSE>>=
plot(lc, type = "summary")
@

\noindent Additionally, we can simply plot the dendrogram on its own with coloured community clusters:

<<eval = FALSE>>=
plot(lc, type = "dend")
@


\setkeys{Gin}{width=0.6\linewidth}
\begin{figure}[!ht]
 \centering
\advance\leftskip -1.5cm
<<fig = TRUE, echo = FALSE>>=
plot(lc, type = "members", nodes = head(names(lc$numclusters),10))
@
\caption{Visualizing community membership for nodes that belong to the most communities. Colours indicate community-specific membership.}\label{members}
\end{figure}


\subsection{Analysing link communities}

\subsubsection{Nested communities}

Nodes can belong to multiple link communities, and so it is possible to discover sets of nodes that belong to a community that is entirely nested within a larger community of nodes:

<<results = hide, echo = FALSE>>=
nc <- getAllNestedComm(lc)
@

<<eval = FALSE>>=
getAllNestedComm(lc)
@

<<echo = FALSE>>=
nc
@

\noindent This result indicates that there is one nested community; the nodes in community 9 are entirely nested within the nodes of community 11. We can verify this by plotting these communities as a graph (Fig. \ref{nested}):

<<eval = FALSE>>=
getNestedHierarchies(lc, clusid = 9)
@

\noindent or

<<eval = FALSE>>=
plot(lc, type = "graph", clusterids = c(9,11))
@

\setkeys{Gin}{width=0.6\linewidth}
\begin{figure}[!ht]
 \centering
\advance\leftskip -2.5cm
<<fig = TRUE, echo = FALSE, results = hide >>=
plot(lc, type = "graph", clusterids = c(9,11), frame = TRUE)
@
\caption{Nested community structure revealed by {\tt linkcomm}. YML098W, YCR042C, and YML114C belong to both communities.}\label{nested}
\end{figure}


\subsubsection{Relationships between communities}

We can also explore the relationships between communities based on the numbers of shared nodes. To do this we can hierarchically cluster the communities after scoring the pair-wise similarities between them using the Jaccard coefficient (based on the number of nodes that they share).

<<echo = FALSE, results = hide>>=
cr <- getClusterRelatedness(lc, hcmethod = "ward")
@

<<eval = FALSE>>=
cr <- getClusterRelatedness(lc, hcmethod = "ward")
@


%\setkeys{Gin}{width=0.8\linewidth}
\begin{figure}[!ht]
\advance\leftskip -2.75cm
%<<fig = TRUE, echo = FALSE, results = hide>>=
%par(mfcol=c(1,2),mar=rep(0,4),pty="m",mgp=rep(0,3),xpd=NA)
%getClusterRelatedness(lc)
%cutDendrogramAt(cr, cutat = 1.2)
%@
\centerline{\includegraphics[width=6.8in]{cluster_relatedness.pdf}}
\caption{Dendrograms showing, on the left, the similarity between link communities, and, on the right, clustering between these communities to produce 3 meta-communities.}\label{clusterrelatedness}
\end{figure}


\noindent This function returns a hierarchical clustering object of class ``hclust'' and plots the dendrogram (Fig. \ref{clusterrelatedness}). After inspecting this dendrogram, we can select a height at which to cut the dendrogram and extract the resulting meta-communities.

<<eval = FALSE, results = hide>>=
cutDendrogramAt(cr, cutat = 1.2)
@

<<echo = FALSE, results = hide>>=
tt <- cutDendrogramAt(cr, cutat = 1.2)
@

<<echo = FALSE>>=
print(tt)
@

\noindent This returns the meta-communities (clusters of community IDs). Alternatively, we could have cut the dendrogram using the {\tt cutat} option in the original clustering function, {\tt getClusterRelatedness}. We can verify that these meta-communities make sense by inspecting the communities in the Spencer circle (Fig. \ref{graphs}). Note that nodes may still belong to multiple meta-communities.

\noindent When working with large networks, the algorithm will typically identify large numbers of link communities (hundreds or more), which can be difficult to handle. Therefore, it is useful to collapse these larger numbers of communitites into smaller numbers of meta-communities. This can be achieved with the {\tt meta.communities()} function, which utilises an algorithm to automatically identify clusters from a hierarchical clustering dendrogram \citep{langfelderetal2008}:

<<eval = FALSE>>=
mc <- meta.communities(lc, hcmethod = "ward", deepSplit = 0)
@

\noindent Where the {\tt deepSplit} argument, taking values from 0-4, indicates how fine-grained the clustering should be, with higher values producing more clusters. The function outputs an object of class {\tt linkcomm} but with a smaller set of larger communities.


\subsubsection{Community centrality}

In link communities, nodes may belong to several communities, and so it is possible to measure the importance of a node in a network based on the number of communities to which it belongs. To do this, we weight the membership of a node in a community by how distinct that community is from the other communities to which the same node belongs

\begin{equation}
C_{c}(i)=\sum_{i\in j}^{N}\left(1-\frac{1}{m}\sum_{i\in j\cap k}^{m}S(j,k)\right),
\end{equation}

\noindent where the main sum is over the $N$ communities to which node $i$ belongs, and $S(j,k)$ refers to the similarity between community $j$ and $k$, calculated as the Jaccard coefficient for the number of shared nodes between each community pair, and this is averaged over the $m$ communities paired with community $j$ and in which node $i$ jointly belongs.

Nodes that belong to a lot of different communities will get the largest community centrality scores, whereas nodes that belong to overlapping, nested or few communities will get the lowest scores.\\

\noindent We can calculate this value for a set of nodes that have been assigned to link communities:

<<echo = FALSE, results = hide>>=
cc <- getCommunityCentrality(lc)
@

<<eval = FALSE>>=
cc <- getCommunityCentrality(lc)
@

<<>>=
head(sort(cc, decreasing = TRUE))
@


\noindent Comparing against the unweighted community membership, we find differences:

<<>>=
head(lc$numclusters)
@

\subsubsection{Community modularity and connectedness}

We can also calculate the modularity of communities - the relative number of links within the community versus links outside of the community - and its inverse, community connectedness. The modularity of community $i$ can be written as

\begin{equation}
M_{i}=\left(\frac{e_{w}(i)}{n_{i}(n_{i}-1)/2}\right).\left(\frac{e_{b}(i)}{n_{i}\bar{d}}\right)^{-1},
\end{equation}

\noindent where $e_{w}(i)$ and $e_{b}(i)$ are the number of links within and without community $i$ respectively, $n_{i}$ is the number of nodes in community $i$, and $\bar{d}$ is the average degree of nodes in the network.\\

\noindent We can calculate and plot the modularity of the communities in our network (Fig. \ref{modularity}):

<<eval = FALSE>>=
cm <- getCommunityConnectedness(lc, conn = "modularity")
plot(lc, type = "commsumm", summary = "modularity")
@

\setkeys{Gin}{width=0.6\linewidth}
\begin{figure}[!ht]
 \centering
%\advance\leftskip -2.5cm
<<fig = TRUE, echo = FALSE>>=
plot(lc, type = "commsumm", summary = "modularity", verbose = FALSE)
@
\caption{The modularity of different link communities.}\label{modularity}
\end{figure}

\noindent We can verify that these measures make sense by inspecting the communities in the Spencer circle (Fig. \ref{graphs}).

\subsubsection{User-defined link communities}

It is also possible for the user to extract link communities that are not defined by the maximisation of the link partition density. Instead, the user can inspect the clustering dendrogram and select a different height at which to extract communities:

<<echo = FALSE, results = hide>>=
lc2 <- newLinkCommsAt(lc, cutat = 0.4)
@

<<eval = FALSE>>=
lc2 <- newLinkCommsAt(lc, cutat = 0.4)
@

\noindent Now the number and composition of the communities has changed, but we use the clustering method from the original clustering:

<<>>=
print(lc2)
@


\subsubsection{Community membership of nodes}

We can extract the nodes from single or multiple communities:

<<>>=
getNodesIn(lc, clusterids = c(4,5))
@

We can also find nodes that are shared by sets of communities:

<<>>=
get.shared.nodes(lc, comms = c(3,4))
@


\subsection{Directed and weighted networks}
\label{sec:dirweight}

When analysing directed networks, we need to specify that the network is directed, and/or choose a weight for links that share nodes yet are in the opposite orientation (the default value is 0.5):

<<eval = FALSE>>=
lc <- getLinkCommunities(yeast_pp, directed = TRUE, dirweight = 0.8)
@

\noindent For weighted networks, the input data must be an edge list with an additional third column of numerical weights, for example:

<<>>=
head(weighted)
@

\noindent For both directed and weighted networks, the algorithm will score the similarities between links that share a node using the Tanimoto coefficient:

\begin{equation}
S(e_{ik},e_{jk})=\frac{\mathbf{a}_{i}.\mathbf{a}_{j}}{|\mathbf{a}_{i}|^{2}+|\mathbf{a}_{j}|^{2}-\mathbf{a}_{i}.\mathbf{a}_{j}},
\end{equation}

\noindent where $\mathbf{a}_{i}$ refers to a vector describing the weights of links between node $i$ and the nodes in the first-order neighbourhoods of both nodes $i$ and $j$ (equal to $0$ in the event of an absent link). For directed networks, links to nodes shared by both node $i$ and $j$ are given a user-defined weight below $1$ if they are in the opposite orientation. 


\subsection{Handling large networks}

The {\tt linkcomm} package can handle networks of any size. To do so, the upper triangular dissimilarity matrix used by the hierarchical clustering algorithm is compressed and written to disk as a temporary file. This matrix is then read, modified, and re-written (by a compiled C{}\verb!++! function) as clustering proceeds until the file size is 0 bytes. The speed at which large networks are processed will depend on the power of the computer being used. The size of the file that holds the compressed matrix may also be very large, so hard disk space could be a limiting factor for extremely large networks. In these cases, the hierarchical clustering method will always be ``single'' to enhance performance.

We make no assumptions about the computer resources available to end users, and so we provide a parameter, {\tt edglim}, which can be modified by the user and which determines the maximum permissible size of the input network in terms of links for it to be handled in memory - above this size the dissimilarity matrix will be handled on the disk. The default value is $10^{4}$ links, but this can be modified:

<<eval = FALSE>>=
lc <- getLinkCommunities(yeast_pp, edglim = 10)
@

As a guide, a network with $10^{4}$ links will require $((10^{4})^{2})*8 = 800$ MB to be handled in an uncompressed format in the memory.


\subsection{Exporting link communities to Cytoscape}

Cytoscape is an open source platform for complex-network analysis and visualization \footnote{http://www.cytoscape.org/}. We can export our link communities into an edge attribute file that can be imported into Cytoscape:

<<eval = FALSE>>=
linkcomm2cytoscape(lc, interaction = "pp", ea = "linkcomms.ea")
@

This will save an edge attribute file to ``linkcomms.ea'' in the current directory. Communities can also be exported to the Clust\&See Cytoscape plug-in which can be used for visualizing and manipulating the clusters produced by various network clustering algorithms \citep{spinellietal2013}:

<<eval = FALSE>>=
linkcomm2clustnsee(lc, file = "temp.cns", network.name = "network")
@

\noindent This will save a Clust\&See compatible file to the current directory.

\clearpage

\section{Customizing network visualizations}


\begin{figure}[!ht]%figure1
\centerline{\includegraphics[width=7in]{custom_graphs.pdf}}
\caption{Customized network visualizations.}\label{custom}
\end{figure}


While default network visualization styles are set in the package, full control of how networks are visualized is possible. To demonstrate this functionality, we will work with the co-appearance network of \emph{Les Mis\'{e}rables}.

<<eval=FALSE>>=
lm <- getLinkCommunities(lesmiserables, plot = FALSE)
@

If we wish to visualize the link communities using node shapes and with an enlarged node size for a particular node (in this case ``Valjean'') then we can achieve this using the {\tt graph.feature} function to generate a vector of node sizes which will be passed to the {\tt plot} function (Fig. \ref{custom}A). This function requires that the indices of the nodes or edges that are to be altered is provided together with the new values ({\tt features}) and the values held by the rest of the nodes or edges in the network ({\tt default}):

<<eval=FALSE>>=
nf <- graph.feature(lm, type = "nodes", indices = which(V(lm$igraph)$name == "Valjean"), 
                    features = 30, default = 5)
plot(lm, type = "graph", vsize = nf, vshape = "circle", shownodesin = 4)
@

We may also plot larger nodes for all of the nodes belonging to a particular community or several communities. Here we enlarge the nodes belonging to community 1 using the {\tt getNodesIn} function, and we drop node labels using the {\tt vlabel} argument (Fig. \ref{custom}B):

<<eval=FALSE>>=
nf <- graph.feature(lm, type = "nodes", indices = getNodesIn(lm, clusterids = 1, 
                    type = "indices"), features = 30, default = 5)
plot(lm, type = "graph", vsize = nf, vshape = "circle", vlabel = FALSE)
@

In addition, we may wish to make particular edges thicker. We can make all of the edges in community 14 thicker using the {\tt getEdgesIn} function (Fig. \ref{custom}C):

<<eval=FALSE>>=
ef <- graph.feature(lm, type = "edges", indices = getEdgesIn(lm, clusterids = 14), 
                    features = 5, default = 1)
plot(lm, type="graph", ewidth = ef)
@

We can also make the edges incident upon a particular node thicker. Here we make all of the edges incident upon ``Myriel'' thicker, and also make this node larger (Fig. \ref{custom}D):

<<eval=FALSE>>=
ef <- graph.feature(lm, type = "edges", indices = getEdgesIn(lm, nodes = "Myriel"), 
                    features = 5, default = 1)
nf <- graph.feature(lm, type = "nodes", indices = which(V(lm$igraph)$name == "Myriel"), 
                    features = 30, default = 5)
plot(lm, type = "graph", vsize = nf, ewidth = ef, vshape = "circle", vlabel = FALSE)
@

Several other options are available and are described in {\tt ?plotLinkCommGraph} and also in {\tt ?igraph.plotting} in the {\tt igraph} R package.

\clearpage


\section{Overlapping Cluster Generator (OCG)}

\cite{beckeretal2012} developed the OCG algorithm to generate clusters of nodes that may belong to more than one cluster. The algorithm iteratively fuses clusters of nodes according to an overlapping extension of Newman's modularity measure until no further gains in overlapping modularity can be attained, thus producing a set of optimally overlapping clusters \citep{beckeretal2012}. This algorithm is integrated into {\tt linkcomm} and in what follows we demonstrate how it can be used.

\subsection{OCG clusters}

OCG clusters can be extracted from networks arranged as an edge list, either directly from a file or from a data frame or matrix within R.

<<results = hide>>=
oc <- getOCG.clusters(lesmiserables)
@

<<echo=FALSE>>=
cat("Calculating Initial class System....Done\nNb. of classes 43\nNb. of edges not within the classes 19\nNumber of initial classes 43\nRunning....\nRemaining classes: None\nReading OCG data...\nExtracting cluster sizes... 100%\n")
@

The algorithm returns an object of class {\tt OCG}. Contained within this object are the clusters together with all the information necessary for visualizing and analysing them further (see {\tt ?getOCG.clusters} for the elements of the {\tt OCG} object). A summary of this object can be printed to the screen:

<<>>=
print(oc)
@

In the OCG algorithm, nodes and not edges belong to communities, and these can be visualized by depicting node community membership according to the number of edges a node shares within each community (see Figure \ref{OCGfig}):

<<eval=FALSE>>=
plot(oc, type = "graph", shownodesin = 7, scale.vertices = 0.1)
@


\begin{figure}[!ht]
 \centering
\centerline{\includegraphics[width=6.5in]{ocg_lesmis.pdf}}
\caption{Visualizing OCG clusters.}
\label{OCGfig}
\end{figure}

The option {\tt scale.vertices} allows us to increase the size of nodes by a specified fraction for each additional community to which it belongs. By setting this to {\tt NULL}, all nodes will be the same size (see {\tt ?plotOCGraph} for all the options available for visualizing {\tt OCG} clusters).


\clearpage



\begin{thebibliography}{}

\bibitem[Ahn {\it et al}., 2010]{ahnetal2010} Ahn, Y.Y., Bagrow, J.P., and Lehmann, S. (2010) Link communities reveal multiscale complexity in networks. {\it Nature}, {\bf 466}, 761-764.

\bibitem[Becker {\it et al}., 2012]{beckeretal2012} Becker, E., Robisson, B., Chapple, C.E., Guenoche, A, and Brun, C. (2012) Multifunctional proteins revealed by overlapping clustering in protein interaction network. {\it Bioinformatics}, {\bf 28}, 84-90.

\bibitem[Evans and Lambiotte, 2009]{evans&lambiotte2009} Evans, T.S., and Lambiotte, R. (2009) Line graphs, link partitions and overlapping communities. {\it Phys. Rev. E.}, {\bf 80}, 016105.

\bibitem[Kalinka and Tomancak, 2011]{kalinka&tomancak2011} Kalinka, A.T., and Tomancak, P. (2011) linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. {\it Bioinformatics}, {\bf 27}, 2011-2012.

\bibitem[Langfelder et al, 2008]{langfelderetal2008} Langfelder, P., Zhang, B., and Horvath, S. (2008) Defining clusters from a hierarchical cluster tree: the Dynamic Tree Cut package for R. {\it Bioinformatics} 24, 719-720.

\bibitem[Radicchi {\it et al}., 2004]{radicchietal2004} Raddichi, F., \emph{et al}. (2004) Defining and identifying communities in networks. {\it Proc. Natl Acad. Sci USA}, {\bf 101}, 2658-2663.

\bibitem[Spencer, 2010]{spencer2010} Spencer, R., (2010). http://scaledinnovation.com/analytics/communities/comlinks.html.

\bibitem[Spinelli {\it et al}, 2013]{spinellietal2013} Spinelli, L., Gambette, P., Chapple, C. E., Robisson, B., Baudot, A., Garreta, H., Tichit, L., Guenoche, A., and Brun, C. (2013). Clust\&See: a Cytoscape plugin for the identification, visualization and manipulation of network clusters. {\it BioSystems} 113, 91-95.

\bibitem[Yu {\it et al}., 2008]{yuetal2008} Yu, H., \emph{et al}. (2008) High-quality binary protein interaction map of the yeast interactome network. {\it Science}, {\bf 322}, 104-110.



\end{thebibliography}


\end{document}
